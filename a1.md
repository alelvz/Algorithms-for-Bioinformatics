
---

# CS249 Assignment 2 Report

## Task 1: Basic genome assembly algorithms

This repository contains implementations and evaluations of two core genome assembly algorithms:

- **De Bruijn Graph (DBG)** assembler
- **Overlap-Layout-Consensus (OLC)** assembler

The algorithms are implemented in the codes dbg.py ( De Bruijn Graph assembler), olc.py (OLC assembler for short reads), and olc_long.py (OLC assembler for long reads)

Usage:

### üöÄ Usage

Below are instructions to run each assembler manually, as well as how to use the provided SLURM scripts for batch processing.

#### 1Ô∏è‚É£ `dbg.py` ‚Äì De Bruijn Graph Assembler

**Description**: Constructs a de Bruijn graph using k-mers and traverses Eulerian paths to generate contigs.

**Usage**:
```bash
python dbg.py -i <input.fastq> -k <kmer_size> -o <output.fasta> [-c <min_coverage>]
```

Arguments:
-i: Input FASTQ file
-k: K-mer size (e.g., 40)
-o: Output FASTA file
-c: (Optional) Minimum k-mer coverage to keep a node (default: 1)

#### 2Ô∏è‚É£ `olc.py` ‚Äì OLC Assembler for Short Reads

**Description**: Computes overlaps between reads using Hamming distance and builds an overlap graph to derive contigs.

**Usage**:
```bash
python olc.py -i <input.fastq> -o <output.fasta> -m <min_overlap> -M <max_mismatches> -c <min_contig_len>
```

Arguments:
-i : Input FASTQ file
-o : Output FASTA file
-m : Minimum required overlap length
-M : Maximum number of mismatches allowed in overlap
-c : Minimum contig length to report

#### 3Ô∏è‚É£ `olc_long.py` ‚Äì  OLC Assembler for Long Reads (ONT)

**Description**: Optimized for long, noisy reads from ONT; uses identity threshold instead of mismatch count.

**Usage**:
```bash
python olc_long.py <input.fastq> <output.fasta> -m <min_overlap> -i <min_identity>
```

Arguments:
<input.fastq> : Input FASTQ file (positional)
<output.fasta> : Output FASTA file (positional)
-m : Minimum overlap length
-i : Minimum identity (e.g., 0.80 = 80%)


### üöÄ Run and evaluate
All assemblies were executed using the provided SLURM scripts: `run_dbg.sh` for the De Bruijn Graph assembler and `run_olc.sh` for both short-read and long-read OLC assemblies. Evaluation of the resulting assemblies was performed using QUAST through the `quast.sh` script. The full set of QUAST output reports is stored in the `quast/quast_results/` directory, while a summary of key evaluation metrics across all assemblies is consolidated in `quast/quast_summary.tsv`.

## Task 1.3: Applications of assembly algorithms

### 1Ô∏è‚É£ Assembly graph exploration of Toy Reads

To explore the assembly graph structure, we used our custom De Bruijn Graph assembler (`dbg.py`) with the toy dataset `reads_b.fastq` and a k-mer size of 40. The assembly graph was output directly in GFA format as part of the implementation. We then visualized this graph using [Bandage](https://rrwick.github.io/Bandage/) with the following command:

```bash
Bandage image reads_b_dbg_k40.gfa reads_b_dbg_k40.png
```

#### üñºÔ∏è Graph Visualization

Below is the resulting assembly graph for `reads_b.fastq`:

![reads\_b\_dbg\_k40.png](file-RWP9sSDeUkUKTb6bjz2rSn)

#### üîç Interpretation

The graph shows a long linear contig with a small bubble near the beginning. This **bubble** indicates a region of ambiguity‚Äîoften caused by sequencing errors or low-complexity/repeat regions. While the majority of the graph is linear (indicating high confidence in the path), such bubbles are common in real assembly scenarios and can be resolved by incorporating coverage information or applying heuristics to collapse paths.

---

### üß† How This Helps Improve Assembly

Visualizing assembly graphs allows us to:

* Detect structural issues (e.g., bubbles, loops, dead ends)
* Evaluate graph complexity and branching
* Identify optimal `k` values by comparing graph simplicity across runs
* Guide algorithmic improvements (e.g., bubble popping, tip trimming, graph simplification)

This analysis shows that although our assembler can reconstruct linear segments well, incorporating error correction or adjusting `k`-mer filtering thresholds could help resolve ambiguous regions for improved contig quality.

---


